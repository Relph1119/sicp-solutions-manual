# 第1章 构造过程抽象
&emsp;&emsp;常用CommonLisp语法：  
- 过程定义`define`
    ```lisp
    (define (<name> <formal parameters>) <body>)
    ```
    &emsp;&emsp;其中`<name>`是一个符号，过程定义将在环境中关联于这个符号。`<formal parameters>`（形式参数）是一些名字，它们用在过程体中，用于表示过程应用时与它们对应的各个实际参数。`<body>`是一个表达式，在应用这一过程时，这一表达式中的形式参数将用与之对应的实际参数取代，对这样取代后的表达式求值，产生出这个过程应用的值。
- 条件表达式
    ```lisp
    (cond (<p_1> <e_1>)
        (<p_2> <e_2>)
        (<p_n> <e_n>))
    ```
    &emsp;&emsp;条件表达式的求值方式如下：首先求值`<p_1>`，如果它的值是false, 那么就去求`<p_2>`，如果`<p_2>`的值是false就去求值`<p_3>`，这一过程继续做下去，直到发现某个谓词的值为真。此时解释器就返回相应子句中的序列表达式`<e>`的值，以这个值作为整个条件表达式的值。如果无法找到值为真的`<p>`，`cond`的值就没有定义。
    ```lisp
    (if <predicate> <consequent> <alternative>)
    ```
    &emsp;&emsp;如果`<predicate>`得到真值，就求值`<consequent>`并返回其值，否则求值`<alternative>`并返回其值。
- `and`表达式
    ```lisp
    (and <e_1> <e_2> ... <e_n>)
    ```
    &emsp;&emsp;将从左到右一个个求值`<e>`，如果某个`<e>`得到假，这一`and`表达式的值就是假，后面那些`<e>`不再求值。如果前面所有的`<e>`都求出真值，表达式的值就是最后那个`<e>`的值。
- `or`表达式
    ```lisp
    (or <e_1> <e_2> ... <e_n>)
    ```
    &emsp;&emsp;将从左到右一个个求值`<e>`，如果某个`<e>`得到真，这一`and`表达式的值就是`<e>`的值，后面那些`<e>`不再求值。如果前面所有的`<e>`都求出假值，表达式的值就是假。
- `not`表达式
    ```lisp
    (not <e>)
    ```
    &emsp;&emsp;如果`<e>`求出的值是假，`not`表达式的值就是真；否则其值为假。

## 练习1.1 
&emsp;&emsp;下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。
```lisp
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (> b a) b a))
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
```
**解答**：
```lisp
10
```
值为10  
```lisp
(+ 5 3 4)
```
值为12
```lisp
(- 9 1)
```
值为8
```lisp
(/ 6 2)
```
值为3
```lisp
(+ (* 2 4) (- 4 6))
```
值为6
```lisp
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
```
此时$a=3, b=4$，则$a+b+(a*b)$值为19
```lisp
(= a b)
```
值为`#f`
```lisp
(if (and (> b a) (< b (* a b)))
    b
    a)
```
由于$b > a$并且$b < (a * b)$，则表达式的值为$b$，故值为4
```lisp
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
```
由于$a=3,b=4$，则表达式的值为$6+7+a$，故值为16
```lisp
(+ 2 (if (> b a) b a))
```
由于$a=3,b=4$，$b>a$，则`(if (> b a) b a)`表达式的值为4，故整个表达式的值为6
```lisp
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
```
观察第一个`cond`表达式，其值为$b$故为4，整个表达式的值$=4*4=16$

## 练习1.2
请将下面表达式变换为前缀形式：$$\frac{\displaystyle 5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}$$
**解答：**
```lisp
(\ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) 
   (* 3 (- 6 2) (- 2 7)))
```

## 练习1.3
请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。
**解答：**
```lisp
(define (sum-two-max-value a b c) 
    (cond ((and (> a c) (> b c)) (+ a b))
          ((and (> a b) (> c b)) (+ a c))
          ((and (> b a) (> c a)) (+ b c))
    ))
```

## 练习1.4
请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为：
```lisp
(define (a-plus-abs-b a b)
 ((if (> b 0) + -) a b))
```
**解答：**
上述表达式的意思是计算$a+|b|$

## 练习1.5
Ben Bitdiddle发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。他定义了下面两个过程：
```lisp
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
```
而后他求值下面的表达式：
```lisp
(test 0 (p))
```