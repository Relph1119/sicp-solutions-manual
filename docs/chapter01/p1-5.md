# 练习1.5
Ben Bitdiddle发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。他定义了下面两个过程：
```lisp
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
```
而后他求值下面的表达式：
```lisp
(test 0 (p))
```
如果某个解释器采用的是应用序求值，Ben会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式`if`的求值规则总是一样的。其中的谓词部分先求值，根据其结果确定随后求值的子表达式部分。）  
**解答：**  
&emsp;&emsp;根据书中1.1.5节介绍
>“完全展开而后归约”的求值模型称为**正则序求值**，与之对应的是现在解释器里实际使用的“先求值参数而后应用”的方式称为**应用序求值**。  

&emsp;&emsp;观察下面的过程定义，无论解释器使用的是什么求值方式，调用`(p)`总是进入一个无限循环，因为函数`p`会不断调用自身，最后只能强制将解释器进程杀掉。
```lisp
(define (p) (p))
```
&emsp;&emsp;在应用序中，所有被传入的实际参数会立即被求值，如果解释器是应用序，在执行`(test 0 (p))`时，实际参数`0`和`(p)`都会被求值，根据上述描述，执行`(p)`时，Ben的测试会陷入停滞。  
&emsp;&emsp;在正则序中，传入的实际参数只有在有需要时才会被求值，如果解释器是正则序，执行`(test 0 (p))`时，会进入`if`语句，由于传入的`x=0`，最后表达式的返回值为0。在正则序求值中，调用`(p)`始终没有被执行，所以不会产生无限循环。